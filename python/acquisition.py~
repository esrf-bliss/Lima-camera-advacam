import pypixet
import os
import datetime
import time
import threading


class acqThread (threading.Thread):
   def __init__(self, minipix):
      threading.Thread.__init__(self)
      self.minipix = minipix

   def run(self):
      print ("Starting acqThread")
      rc = self.minipix.detector.doAdvancedAcquisition(self.minipix.acqNbFrames,\
                                                       self.minipix.acqExpoTime,\
                                                       pypixet.pixet.PX_ACQTYPE_FRAMES,\
                                                       pypixet.pixet.PX_ACQMODE_TRG_SWSTART, 0, 0, "")
      print ("acq thread #{rc}: stop the Acq.")

      self.minipix._stopAcq()
      
      print (f"Acq thread #{rc} finished")
      
      

class Camera:
    #Detector settings
    SET_BIAS_VOLTAGE = 200
    ENERGY_THRESHOLD = 3.6
    
    #More flags from Pixet GUI -> Python Scripting -> Help -> Function List
    PX_THLFLAG_ENERGY = 0x2
    PX_TPX3_OPM_TOATOT = 0
    PX_TPX3_OPM_TOA = 1
    PX_TPX3_OPM_EVENT_ITOT = 2
    PX_TPX3_OPM_TOT_NOTOA = 3

    def __init__(self, config_file = "/opt/pixet/factory/MiniPIX-D05-W0051.xml"):
        
        pypixet.start()

        time.sleep(1)

        # below example code copied from pixetacq_server.py provided by ID20 (https://confluence.esrf.fr/pages/viewpage.action?spaceKey=ID20WK&title=MiniPIX)

        alldevices = pypixet.pixet.devices() # get all devices (including motors, ...)
        detectors = pypixet.pixet.devicesByType(3) # get all connected Timepix3 
        self.detector = detectors[0] # get first connected detector
        self.detector.loadConfigFromFile(config_file)

        #self.detector.setBias(SET_BIAS_VOLTAGE)
        #time.sleep(1)
        self.detector.setThreshold(0, self.ENERGY_THRESHOLD, self.PX_THLFLAG_ENERGY) #Energy threshold
        time.sleep(1)
        tpx3modes = ['ToA+ToT','ToA','Event+iToT','ToT']

        self.detector.setOperationMode(self.PX_TPX3_OPM_EVENT_ITOT)
        time.sleep(1)

        detector = self.detector
        print('DETECTOR INFO')
        print('  Name:             ', detector.fullName())
        print('  Width x Height:   ', detector.width(), 'X', detector.height())
        print('  Pixel count:      ', detector.pixelCount())
        print('  Chip count:       ', detector.chipCount())
        print('  Chip IDs:         ', detector.chipIDs()) # list of detector chip IDs
        print('')
        print('  Energy threshold: ', detector.threshold(0, self.PX_THLFLAG_ENERGY), 'keV') # gets the threshold of chip 0 in energy
        print('  Set bias voltage: ', detector.bias()) # return device bias volage (set value)
        print('  Sensed bias:      ', detector.biasVoltageSense(), ' V /', detector.biasCurrentSense(), 'uA') 
        print('  Refresh support:  ', detector.isSensorRefreshSupported())
        print('  Mode:             ', tpx3modes[detector.operationMode()])
        print('  Temperature:      ', detector.temperature(), ' degC')
        print('')

        self.__prepared = False

        self.__nb_frames = 1
        self.__expo_time = 1.0
        self.__acquired_frames = 0
        self.__status = "Ready"
        
    def __del__(self):
        pypixet.exit()

    def quit(self):
        pypixet.exit()
        
    def callback(self, value):
        print("Callback " + str(value))
        frame = self.detector.lastAcqFrameRefInc()
        data = frame.data()
        frame.destroy()

        if self.__acquired_frames != value:
            self.__acquired_frames = value

    def prepareAcq(self):
        if not self.__prepared:
            self.detector.registerEvent(pypixet.pixet.PX_EVENT_ACQ_FINISHED, self.callback, self.callback)
            self.__prepared = True
            self.__acquired_frames = 0

    def getStatus(self):
        #if self.detector.isReadyForSoftwareTrigger(0):
        return self.__status
        
    def startAcq(self):
        if self.__acquired_frames == 0:
            self.acqthread = acqThread(self)
            self.acqthread.start()
            self.__status = "Acquiring"
            
        rc = self.detector.doSoftwareTrigger(0)
        print(f"startAcq(): Trigger {self.acquiredFrames+1}")        

    def stopAcq(self):
        self._stopAcq(abort=True)
        
    def _stopAcq(self, abort=False):
        self.detector.unregisterEvent(pypixet.pixet.PX_EVENT_ACQ_FINISHED, self.callback, self.callback)
        if abort:
            self.detector.abortOperation()
            self.acqthread.join()
        self.__prepared = False
        self.__status = "Ready"

    @property
    def acqNbFrames(self):
        return self.__nb_frames

    @acqNbFrames.setter
    def acqNbFrames(self, frames):
        self.__nb_frames = frames

    @property
    def acqExpoTime(self):
        return self.__expo_time

    @acqExpoTime.setter
    def acqExpoTime(self, time):
        self.__expo_time = time
    
    @property
    def acquiredFrames(self):
        return self.__acquired_frames

    @property
    def fullName(self):
        return self.detector.fullName()
    @property
    def width(self):
        return self.detector.fullName()
    @property
    def height(self):
        return self.detector.fullName()
    
    @property
    def bpp(self):
        # According to the doc "AdvaPIX\ TPX3\ &\ MiniPIX\ TPX3\ -\ User\ Manual.pdf", page 7:
        # ToT & ToA: Tot 14bit, ToA 10bit, Fast ToA 4bit@640MHz
        # Only ToA:  ToA 14bit Only Fast ToA 4bit@640 MHz
        # Event Count & Integral ToT: Integral ToT 14bit, Hit Counter: 10bit
        return 16
    
    
def main():
    minipix = Camera()

    minipix.acqNbFrames = 10
    minipix.acqExpoTime = 0.4

    minipix.prepareAcq()
    minipix.startAcq()

    nb_frames = 1
    while minipix.getStatus() != "Ready":
        if minipix.acquiredFrames == nb_frames:
            minipix.startAcq()
            nb_frames += 1
        
        
    
if __name__ == "__main__":
    sys.exit(main())
